import os
import cv2
import math
import json
import copy
import shutil
import random
import numpy as np
import pandas as pd
from .utils import read_json, dump_json, read_txt, write_txt


def csv_to_json(img_dir, csv_dir, json_dir):
    """ Convert labeled line segment csv files into json formatted files 
    readable from labelme, so that users could check or change labels if necessary.
    """
    os.makedirs(json_dir, exist_ok=True)
    line_seg = {'TS_BT':'seg1', 'BT_VS':'seg2'}
    names = [f[:-4] for f in os.listdir(img_dir) if f.endswith('.png')]
    line_seg_dict = {}
    json_template = {
      "version": "4.2.10",
      "flags": {},
      "shapes": [],       # to fill
      "imagePath": "",    # to fill
      "imageData": None,
      "imageHeight": -1,  # to fill
      "imageWidth": -1    # to fill
    }
    for name in names:
        data = copy.deepcopy(json_template)
        img = cv2.imread(os.path.join(img_dir, name+'.png'))
        H, W, _ = img.shape
        data['imagePath'] = name+'.png'
        data['imageHeight'] = H
        data['imageWidth'] = W
        for line in ['TS_BT', 'BT_VS']:
            csv_file = os.path.join(csv_dir, name+' '+line+'.csv')
            if not os.path.isfile(csv_file):
                continue
            xy = pd.read_csv(csv_file).to_numpy().tolist()
            data['shapes'].append({'flags':{}, 
                                   'group_id':None, 
                                   'label':line_seg[line], 
                                   'points':xy, 
                                   'shape_type':'linestrip'})
        dump_json(os.path.join(json_dir, name+'.json'), data)

def add_csv_to_whole_json(whole_json_dir, csv_dir, combined_json_dir):
    """ Add part seg labels from csvs to json files. The json files are generated by
    manually labeling whole ship masks using labelme.
    """
    names = [f[:-5] for f in os.listdir(whole_json_dir) if f.endswith('.json')]
    whole_seg_dict = {name:{'TS_BT':None, 'BT_VS':None} for name in names}
    cnt = 0
    for name in names:
        for line in ['TS_BT', 'BT_VS']:
            if os.path.isfile(os.path.join(csv_dir, name+' '+line+'.csv')):
                whole_seg_dict[name][line] = os.path.join(csv_dir, name+' '+line+'.csv')
                cnt += 1
    # print(cnt)
    line_seg = {'TS_BT':'seg1', 'BT_VS':'seg2'}
    for name in names:
        data = read_json(os.path.join(whole_json_dir, name+'.json'))
        for line,csv in whole_seg_dict[name].items():
            if csv:
                xy = pd.read_csv(csv).to_numpy()
                data['shapes'].append({'flags':{}, 
                                       'group_id':None, 
                                       'label':line_seg[line], 
                                       'points':xy.tolist(), 
                                       'shape_type':'linestrip'})
        dump_json(os.path.join(combined_json_dir, name+'.json'), data)


def rotate_point(point, origin, angle):
    """
    Rotate a point counterclockwise by a given angle around a given origin.
    The angle should be given in radians.
    """
    ox, oy = origin
    px, py = point
    qx = ox + math.cos(angle) * (px - ox) - math.sin(angle) * (py - oy)
    qy = oy + math.sin(angle) * (px - ox) + math.cos(angle) * (py - oy)
    return (qx, qy)

def extend_line(points, W, H):
    if points[0][0] > points[-1][0]:
        points.reverse()
    start = points[0]
    end = points[-1]
    cusion = 10
    # check if needed to extend
    if 0 < start[0] < cusion or 0 < start[1] < cusion or 1 < H - start[1] < cusion:
        second = points[1]
        z = np.polyfit([start[0], second[0]], [start[1], second[1]], 1)
        if start[0] < cusion: # extend left
            p = np.poly1d(z)
            newp = [0, p(0)]
        elif start[1] < cusion: # extend up
            newp = [-z[1]/z[0], 0]
        else: # extend down
            newp = [(H-z[1])/z[0], H]
        points = [newp] + points
    if 1 < W - end[0] < cusion or 0 < end[1] < cusion or 1 < H - end[1] < cusion:
        second = points[-2]
        z = np.polyfit([second[0], end[0]], [second[1], end[1]], 1)
        if W-end[0] < cusion: # extend right
            p = np.poly1d(z)
            newp = [W, p(W)]
        elif end[1] < cusion: # extend up
            newp = [-z[1]/z[0], 0]
        else: # extend down
            newp = [(H-z[1])/z[0], H]
        points = points + [newp]
    return points

def smooth_line_at_border(bon, w, h):
    C = 2 # two boundaries
    for i in range(w-1):
        for c in range(C):
            if bon[i][c] == 0 and bon[i+1][c] > h-5: # a jump found at start
                for j in range(i+1):
                    bon[j][c] = h - 1
    for i in range(w-1, 0, -1):
        for c in range(C):
            if bon[i][c] == 0 and bon[i-1][c] > h-5: # a jump found at end
                for j in range(i, w):
                    bon[j][c] = h - 1
    return bon


def devide_mask_by_lines(img_dir, json_dir, 
                         img_layout_dir, label_layout_dir, 
                         wh=(640, 480), rotate=False, shift=False):
    os.makedirs(img_layout_dir, exist_ok=True)
    os.makedirs(label_layout_dir, exist_ok=True)
    names = [os.path.splitext(f)[0] for f in os.listdir(json_dir) if f.endswith('.json')]
    for name in names:
        print('processing', name)   
        img_name = os.path.join(img_dir, name+'.png')
        json_name = os.path.join(json_dir, name+'.json')
        img = cv2.imread(img_name)
        labels = read_json(json_name)
        H, W = labels['imageHeight'], labels['imageWidth']
        whole_mask = np.zeros((H, W, 3))
        mask = np.zeros((H, W, 3))
        
        # randomly rotate image to augment data
        if rotate:
            mind, maxd = 3, 15
            degree = 0
            while abs(degree) < mind:
                degree = random.randint(-maxd, maxd)
            print('rotate', degree)
            M = cv2.getRotationMatrix2D((W/2, H/2), degree, 1)
            img = cv2.warpAffine(img, M, (W, H), borderMode=cv2.BORDER_CONSTANT)
        
        segs = set()
        thickness = max(max(H, W) // 1000 + 2, 5)
        # first draw the two line boundaries on mask
        for shape in labels['shapes']:
            points = shape['points']
            if rotate:
                points = [rotate_point(point, (W/2, H/2), -math.radians(degree)) for point in points]
            if shape['label'] == 'whole':
                points = np.array([[round(p[0]), round(p[1])] for p in points], dtype=np.int32)
                cv2.fillPoly(whole_mask, [points], color=(255,255,255))
            elif shape['label'] == 'seg1':
                segs.add('seg1')
                points = extend_line(points, W, H)
                points = np.array([[round(p[0]), round(p[1])] for p in points], dtype=np.int32)
                cv2.polylines(mask, [points], isClosed=False, color=(0,255,0), thickness=thickness)
            elif shape['label'] == 'seg2':
                segs.add('seg2')
                points = extend_line(points, W, H)
                points = np.array([[round(p[0]), round(p[1])] for p in points], dtype=np.int32)
                cv2.polylines(mask, [points], isClosed=False, color=(0,0,255), thickness=thickness)
        
        # skip those only with one seg line
        if len(segs) < 2:
            continue
            
        # zero out the background outside of whole mask
        img = np.where(whole_mask > 0, img, 0)
        
        # zero out the part of segs outside of whole mask
        mask_pure = np.where(whole_mask > 0, mask, 0)
        
        # decide ship area from whole mask
        horizontal = np.sum(whole_mask[:,:,0], axis=0)
        vertical = np.sum(whole_mask[:,:,0], axis=1)
        # print(H, W, horizontal.shape, vertical.shape)
        w1 = next((i for i in range(W) if horizontal[i] != 0), None) # place of first non-zero element
        w2 = next((i for i in range(W-1, -1, -1) if horizontal[i] != 0), None) # place of last non-zero element
        h1 = next((i for i in range(H) if vertical[i] != 0), None) # place of first non-zero element
        h2 = next((i for i in range(H-1, -1, -1) if vertical[i] != 0), None) # place of last non-zero element
        # print(h1, w1, h2, w2)
        
        # randomly shift ship to augment data
        if shift:
            minp, maxp = 0.05, 0.10
            w1shift = random.randint(int((w2 - w1) * minp), int((w2 - w1) * maxp))
            h1shift = random.randint(int((h2 - h1) * minp), int((h2 - h1) * maxp))
            w2shift = random.randint(int((w2 - w1) * minp), int((w2 - w1) * maxp))
            h2shift = random.randint(int((h2 - h1) * minp), int((h2 - h1) * maxp))
            print(w1shift, h1shift, w2shift, h2shift)
            w1 += w1shift
            h1 += h1shift
            w2 -= w2shift
            h2 -= h2shift
    
        # crop ship and segs, and resize to (w,h)
        w, h = wh
        ship = img[h1:h2+1, w1:w2+1]
        ship = cv2.resize(ship, (w, h))
        mask = mask[h1:h2+1, w1:w2+1] # seg contains extension to background
        mask = cv2.resize(mask, (w, h))
        cropped_mask = mask_pure[h1:h2+1, w1:w2+1] # seg is within the ship foreground
        cropped_mask = cv2.resize(cropped_mask, (w, h))
        
        # determine start & end points of TS/BT, BT/VS boundaries
        mask_horizontal = np.sum(cropped_mask, axis=0)
        w1_begin = next((i for i in range(w) if mask_horizontal[i, 1] != 0), None)
        w1_end   = next((i for i in range(w-1, -1, -1) if mask_horizontal[i, 1] != 0), None)
        w2_begin = next((i for i in range(w) if mask_horizontal[i, 2] != 0), None)
        w2_end   = next((i for i in range(w-1, -1, -1) if mask_horizontal[i, 2] != 0), None)
        if w1_begin is None or w1_end - w1_begin < 100 or w2_begin is None or w2_end - w2_begin < 100:
            continue
        # determine positions of the seg lines on image
        seg1 = []
        seg2 = []
        for i in range(w):
            h1_begin = next((j for j in range(h) if mask[j, i, 1] != 0), None)
            h1_end = next((j for j in range(h-1, -1, -1) if mask[j, i, 1] != 0), None)
            # print(i, h1_begin, h1_end)
            h1_begin = 0 if h1_begin is None else h1_begin
            h1_end = 0 if h1_end is None else h1_end
            seg1.append((h1_begin + h1_end) / 2)
            
            h2_begin = next((j for j in range(h) if mask[j, i, 2] != 0), None)
            h2_end = next((j for j in range(h-1, -1, -1) if mask[j, i, 2] != 0), None)
            # print(i, h2_begin, h2_end)
            h2_begin = 0 if h2_begin is None else h2_begin
            h2_end = 0 if h2_end is None else h2_end
            seg2.append((h2_begin + h2_end) / 2)
        bon = np.array(list(zip(seg1, seg2)))
        bon = smooth_line_at_border(bon, w, h)
        
        # write img and seg to files
        r = '_r{}'.format(degree) if rotate else ''
        s = '_s{}'.format((w1shift+h1shift+w2shift+h2shift)//4) if shift else ''
        basename = name + r + s
        ship_name = os.path.join(img_layout_dir, basename+'.png')
        mask_name = os.path.join(label_layout_dir, basename+'.png')
        seg_num_name = os.path.join(label_layout_dir, basename+'.txt')
        
        cv2.imwrite(ship_name, ship)
        cv2.imwrite(mask_name, cropped_mask)
        txt_content = {'H':H, 'W':W, 'h':h, 'w':w,
                       'h1':h1, 'w1':w1, 'h2':h2, 'w2':w2, 
                       'w1_begin':w1_begin, 'w1_end':w1_end, 
                       'w2_begin':w2_begin, 'w2_end':w2_end, 
                       'bon':bon}
        write_txt(seg_num_name, txt_content)        

def devide_mask_by_lines_test(img_dir, whole_mask_dir, 
                              img_layout_dir, label_layout_dir, 
                              wh=(640, 480)):
    os.makedirs(img_layout_dir, exist_ok=True)
    os.makedirs(label_layout_dir, exist_ok=True)
    names = [os.path.splitext(f)[0] for f in os.listdir(img_dir) if f.endswith('.png')]
    for name in names:
        print('processing', name)   
        img_name = os.path.join(img_dir, name+'.png')
        whole_mask_name = os.path.join(whole_mask_dir, name+'.png')
        img = cv2.imread(img_name)
        whole_mask = cv2.imread(whole_mask_name)
        H, W, _ = img.shape
            
        # zero out the background outside of whole mask
        img = np.where(whole_mask > 0, img, 0)
        
        # decide ship area from whole mask
        horizontal = np.sum(whole_mask[:,:,0], axis=0)
        vertical = np.sum(whole_mask[:,:,0], axis=1)
        w1 = next((i for i in range(W) if horizontal[i] != 0), None) # place of first non-zero element
        w2 = next((i for i in range(W-1, -1, -1) if horizontal[i] != 0), None) # place of last non-zero element
        h1 = next((i for i in range(H) if vertical[i] != 0), None) # place of first non-zero element
        h2 = next((i for i in range(H-1, -1, -1) if vertical[i] != 0), None) # place of last non-zero element

        # crop ship and segs, and resize to (w,h)
        w, h = wh
        ship = img[h1:h2+1, w1:w2+1]
        ship = cv2.resize(ship, (w, h))
        cropped_mask = whole_mask[h1:h2+1, w1:w2+1]
        cropped_mask = cv2.resize(cropped_mask, (w,h))
        
        # determine start & end points of TS/BT, BT/VS boundaries
        w1_begin = 0
        w1_end   = w
        w2_begin = 0
        w2_end   = w
        # determine positions of the seg lines on image
        seg1 = [0] * w
        seg2 = [0] * w
        bon = np.array(list(zip(seg1, seg2)))
        
        # write img and seg to files
        ship_name = os.path.join(img_layout_dir, name+'.png')
        cropped_mask_name = os.path.join(label_layout_dir, name+'.png')
        seg_num_name = os.path.join(label_layout_dir, name+'.txt')
        cv2.imwrite(ship_name, ship)
        cv2.imwrite(cropped_mask_name, cropped_mask)
        txt_content = {'H':H, 'W':W, 'h':h, 'w':w,
                       'h1':h1, 'w1':w1, 'h2':h2, 'w2':w2, 
                       'w1_begin':w1_begin, 'w1_end':w1_end, 
                       'w2_begin':w2_begin, 'w2_end':w2_end, 
                       'bon':bon}
        write_txt(seg_num_name, txt_content)       

def aug_layout(img_layout_dir, label_layout_dir, img_layout_aug_dir, label_layout_aug_dir):
    os.makedirs(img_layout_aug_dir, exist_ok=True)
    os.makedirs(label_layout_aug_dir, exist_ok=True)
    basenames = [f[:-4] for f in os.listdir(img_layout_dir)]
    for basename in basenames:
        print('processing', basename)
        img = cv2.imread(os.path.join(img_layout_dir, basename+'.png'))
        seg = cv2.imread(os.path.join(label_layout_dir, basename+'.png'))
        txt = read_txt(os.path.join(label_layout_dir, basename+'.txt'))
        
        # flip rgb to bgr
        img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        cv2.imwrite(os.path.join(img_layout_aug_dir, basename+'_c.png'), img_rgb)
        cv2.imwrite(os.path.join(label_layout_aug_dir, basename+'_c.png'), seg)
        write_txt(os.path.join(label_layout_aug_dir, basename+'_c.txt'), txt)
        
        # flip left right
        img_lr = np.flip(img, axis=1)
        seg_lr = np.flip(seg, axis=1)
        txt_lr = txt.copy()
        txt_lr['w1'], txt_lr['w2'] = txt_lr['W']-1 - txt_lr['w2'], txt_lr['W']-1 - txt_lr['w1']
        txt_lr['w1_begin'], txt_lr['w1_end'] = txt_lr['w']-1 - txt_lr['w1_end'], txt_lr['w']-1 - txt_lr['w1_begin']
        txt_lr['w2_begin'], txt_lr['w2_end'] = txt_lr['w']-1 - txt_lr['w2_end'], txt_lr['w']-1 - txt_lr['w2_begin']
        txt_lr['bon'] = np.flip(txt_lr['bon'], axis=0)
        cv2.imwrite(os.path.join(img_layout_aug_dir, basename+'_lr.png'), img_lr)
        cv2.imwrite(os.path.join(label_layout_aug_dir, basename+'_lr.png'), seg_lr)
        write_txt(os.path.join(label_layout_aug_dir, basename+'_lr.txt'), txt_lr)


def gen_part_data_wi_labels(img_dir, label_dir,
                            img_layout_dir, label_layout_dir, 
                            img_layout_aug_dir=None, label_layout_aug_dir=None, ):
    # generate layout image/labels
    devide_mask_by_lines(img_dir, label_dir, img_layout_dir, label_layout_dir)
    if img_layout_aug_dir and label_layout_aug_dir:
        # augment data by random shift and rotate
        devide_mask_by_lines(img_dir, label_dir, img_layout_aug_dir, label_layout_aug_dir, 
                             rotate=True, shift=False)
        devide_mask_by_lines(img_dir, label_dir, img_layout_aug_dir, label_layout_aug_dir, 
                             rotate=False, shift=True)
        devide_mask_by_lines(img_dir, label_dir, img_layout_aug_dir, label_layout_aug_dir, 
                             rotate=True, shift=True)
        devide_mask_by_lines(img_dir, label_dir, img_layout_aug_dir, label_layout_aug_dir, 
                             rotate=True, shift=True)
        # augment data by RGB channel reversing and left-right flip
        aug_layout(img_layout_aug_dir, label_layout_aug_dir, img_layout_aug_dir, label_layout_aug_dir)
        aug_layout(img_layout_dir, label_layout_dir, img_layout_aug_dir, label_layout_aug_dir)

def gen_part_data_wo_labels(img_dir, whole_mask_dir, img_layout_dir, label_layout_dir):
    devide_mask_by_lines_test(img_dir, whole_mask_dir, img_layout_dir, label_layout_dir)
